/*
*	SKKU Graduate by 강영훈
*
*
*/



	각 폴더마다 폴더를 설명하는 텍스트파일이 있다.
	각 소스코드마다 부가적인 설명이 들어있다.


1. Beta_Test

	하드웨어가 잘 작동하는지 테스트한 코드이다.
	
	1. Check_Motor		: 모터가 잘 작동하는지 테스트한 코드이다.
	2. Check_Sensor		: 센서에서 값을 잘 읽는지 확인한 코드이다.
	3. Check_Combination	: 센서와 모터가 잘 연동되는지 확인한 코드이다.


2. FirstModel

	파이썬이랑 통신을 하며 학습을 하는 첫 번째 모델이다.

	1. ARDUINO_MOTOR	: 아두이노 파트의 메인 코드이다.
	2. GKD_MPU6050		: mpu6050 센서에 칼만 필터 코드를 적용한 라이브러리이다.

3. CPP_Test_Model

	파이썬에서 cpp 로 바꾸면서 작동이 잘 되는지 테스트를 하기 위한 코드이다.
	next angle = previous_angle + 3 * present_speed + previous_speed
	라는 간단한 모델로 테스트 모델을 학습시켰다.

	1. Second_Test_Arduino			: 아두이노부에서의 작동코드, 위에서 설정한 가상의 환경을 가동함. 어떠한 신호가 왔는지 LED 로 확인함
	2. Second_Test_Model			: PC 부의 작동코드, Cpp 로 작성됨. 데이터를 받는 과정에서의 노이즈는 없다고 가정함.
	3. SIORSerial				: Cpp 로 시리얼통신을 하기 위한 클래스, 오픈소스에서 발생하는 버그들을 상당 수정하고 이용의 편의성을 개선함.
	4. Test_Gaussian_Random_Variable	: Cpp 로 가우시안 랜덤 변수를 구현한 샘플 코드.

4. SecondModel

	Cpp 로 바꾼 다음에 실제로 학습을 진행한 코드, 로봇이 넘어지면 로봇을 바로 세우고 아두이노의 리셋버튼을 누른다.

	1. Arduino_Part		: 아두이노 파트의 코드이다. 테스트 상황을 리턴하지 않고 실제 측정한 각도를 시리얼로 송신한다,
	2. Second_Model_Project	: PC 파트의 코드이다. 3 에서 테스트했던 모든 기능이 담겨있으며, 액션에 가우시안 랜덤 변수를 추가한다.

5. ThirdModel

	상태모델을 [각도][이전속도][현재속도] 로 설정한 뒤 학습을 시킴

	1. Arduino_Part		: 각 통신간 30ms 의 딜레이를 줘서 모터가 동작을 할 시간을 적당히 줌
	2. ThirdModelProject	: 위의 상태모델을 적용한 학습 코드


6. FourthModel

	상태모델을 [각도][각속도][이전속도][현재속도] 로 설정한 뒤 학습을 진행함
	각속도는 (현재각도 - 이전각도) 로 구함

	1. FourthModelProject	: 위의 상태모델을 적용하여 학습을 한 코드. 상태노드를 클래스로 따로 빼서 구현함. 메인함수에서 사용하는 함수들을 헤더파일로 뻄.
	2. Arduino_Part		: 5번이랑 똑같은 소스코드

7. Simulation Program

	실제 하드웨어를 구동하는것이 아니라 가상 물리 환경을 설정하고 시뮬레이션 프로그램을 만듬
	
	각가속도 = (모터가속도*sin(각도) - 중력가속도*cos(각도)) / 반지름
	각속도   = 각속도 + 각가속도 * 시간
	각	 = 각도	+ 각속도 * 시간 + 각가속도 * 시간^2 / 2
	모터가속도 = (현재속도 - 이전속도) / 시간

	1. Reinforcement_Study	: 학습을 위한 프로그램. 넘어지는 상황이 발생하면 바로 이전상황으로 돌아가서 넘어지지 않는 다른 상황을 찾는다. 도저히 못찾겠으면 그 이전상황으로 돌아간다.
	2. Reinforcement_Action	: 학습을 한 데이터를 기반으로 시뮬레이션을 돌려본다. 0.5초마다 다음 상황을 콘솔화면으로 출력한다.



